通常，一个类型的各个值会被分到不同的\textit{类} （\textit{class}）中，每个被分类的数据都有其与众不同的内在结构。
以飞机的坐标点为例，点的数据分类取决于它是笛卡尔坐标系还是极坐标系，两种方法都会需要两个实数来表示点的位置。
在笛卡尔坐标系中，这两的数字对应着点的 $ x $ 与 $ y $ 的坐标；但在极坐标系中，它们对应着点的距极点的距离 $ r $ 以及与极轴夹角 $ \theta $。
每个被分类的值叫做该类的一个 \textit{对象}（\textit{object}）或 \textit{实例} （\textit{instance}）。
类决定了被分类的数据，该类的\textit{实例类型}（\textit{instance type}），的类型；该数据本身称之为对象的\textit{实例数据}（\textit{instance data}）。

\textit{方法}（\textit{method}）是作用在被分类数据上的函数。方法的行为由它参数的类别决定\footnote[1]{简单起见，我们假定可以同时分派多个参数的类。我们只关注单一的分派。}。
方法的\textit{分派}（\textit{dispatch}）由参数的类别决定。由于这种选择是运行时发生的，
因此叫\textit{动态分派}（\textit{dynamic dispatch}）。比如，用来计算点到原点距离平方的方法在
两种坐标系下表现不同。在笛卡尔坐标系中，距离的平方为 $x^2 + y^2$，而在极坐标系中为 $r^2$；
再比如，判断点的所在象限时，笛卡尔坐标系的点需要考察 $ x $ 与 $ y $ 的符号，而在极坐标系中需要考察 $ \theta $ 除以 $ \pi / 2 $。

动态分派经常用一类特定的实现策略描述，我们称之为\textit{基于类的}（\textit{class-based}）组织。在这种组织中，
每个对象被描述为作用在该对象的上的一列方法。有时我们也用一种与其等价的组织，\textit{基于方法的}（\textit{method-based}）组织，
其中方法的行为随着作用对象的类型不同而不同。不管是哪一种组织，核心想法都是：甲对象被分为某一类，乙方法在这个类上分派。基于类的与基于方法的组织之间是可以互换的，
实际上它们是由自然二元关系加类型和积类型相联系的。观察每个对象上的每个方法的行为，可以解释这种对称性，我们称之为\textit{分派矩阵}（\textit{dispatch matrix}）。
由分派矩阵，我们会发现这两种组织的对称关系是显然的。
